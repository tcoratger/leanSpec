%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION: THE TRANSPORT LAYER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Transport Layer}

Before two nodes can exchange consensus messages, they must solve a more fundamental problem: how to reliably send bytes from one computer to another across the internet. This is the domain of the transport layer.

The challenge is not merely technical---it is also adversarial. The network connecting Ethereum validators is the public internet, an environment where packets can be lost, reordered, duplicated, or intercepted. Any communication protocol must defend against these hazards while maintaining performance under load.

This section describes the transport architecture that underpins Lean Consensus networking. We begin with an overview of the layered design, then examine each component in detail: the QUIC transport protocol, alternative transports for constrained environments, and the cryptographic mechanisms that secure every connection.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUBSECTION: PROTOCOL STACK OVERVIEW
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Protocol Stack Overview}

Network protocols are traditionally organized into layers, where each layer provides services to the layer above it and consumes services from the layer below. This separation of concerns allows each layer to be designed, implemented, and reasoned about independently.

The Lean Consensus network stack consists of four distinct layers, illustrated in Figure~\ref{fig:protocol_stack}. From bottom to top:

\begin{enumerate}
    \item \textbf{Transport Layer.}
    The foundation of all communication. This layer is responsible for moving raw bytes between two endpoints on the internet. It handles the mechanics of packet delivery: breaking data into segments, ensuring they arrive, and reassembling them in order. In Lean Consensus, this role is filled by QUIC (or TCP in fallback scenarios).

    \item \textbf{Security Layer.}
    Raw byte streams are insufficient for a trustless network. Before any application data is exchanged, the two parties must authenticate each other's identities and establish an encrypted channel. This layer implements cryptographic handshakes and ongoing encryption. TLS~1.3 serves this role when using QUIC; the Noise Protocol Framework serves it when using TCP.

    \item \textbf{Multiplexing Layer.}
    A single connection between two nodes must carry many independent conversations simultaneously: block requests, attestation gossip, status exchanges, and more. The multiplexing layer creates the abstraction of multiple logical \emph{streams} over a single underlying connection. In QUIC, this capability is built into the transport itself. For TCP, a separate protocol called Yamux provides equivalent functionality.

    \item \textbf{Application Layer.}
    The top of the stack contains the protocols that actually implement consensus functionality. This includes Gossipsub for message propagation and request-response protocols for direct queries. These protocols operate on streams provided by the multiplexing layer, blissfully unaware of the complexities beneath them.
\end{enumerate}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
        font=\sffamily\small,
        % Layer box styles
        layer_box/.style={
            rectangle,
            draw=#1,
            thick,
            fill=#1!8,
            minimum width=12cm,
            minimum height=1.4cm,
            align=center,
            rounded corners=3pt
        },
        % Arrow style
        data_arrow/.style={
            ->,
            >=Latex,
            ultra thick,
            gray!60,
            line width=3pt
        },
        % Label style
        layer_label/.style={
            font=\footnotesize\sffamily,
            text=gray,
            anchor=west
        },
        % Protocol box inside layer
        proto_box/.style={
            rectangle,
            draw=#1,
            thick,
            fill=white,
            minimum height=0.8cm,
            rounded corners=2pt,
            font=\footnotesize\bfseries
        }
    ]

    % Define vertical spacing
    \def\layerSpacing{1.8cm}

    % --- LAYER 4: APPLICATION (Top) ---
    \node[layer_box=leanpurple] (app) at (0, 3*\layerSpacing) {};
    \node[layer_label] at (-6.3, 3*\layerSpacing) {\textbf{4}};

    % Protocol boxes inside application layer
    \node[proto_box=leanpurple, minimum width=3.5cm] at (-2.5, 3*\layerSpacing) {Gossipsub};
    \node[proto_box=leanpurple, minimum width=3.5cm] at (2.5, 3*\layerSpacing) {Request-Response};

    \node[right=0.3cm, font=\footnotesize\itshape, text=leanpurple!70!black] at (5.5, 3*\layerSpacing) {Application};

    % --- LAYER 3: MULTIPLEXING ---
    \node[layer_box=ethblue] (mux) at (0, 2*\layerSpacing) {};
    \node[layer_label] at (-6.3, 2*\layerSpacing) {\textbf{3}};

    % Show streams abstraction
    \node[proto_box=ethblue, minimum width=2cm] at (-3.5, 2*\layerSpacing) {Stream 1};
    \node[proto_box=ethblue, minimum width=2cm] at (-0.5, 2*\layerSpacing) {Stream 2};
    \node[proto_box=ethblue, minimum width=2cm] at (2.5, 2*\layerSpacing) {Stream 3};
    \node[font=\footnotesize, text=ethblue] at (5, 2*\layerSpacing) {...};

    \node[right=0.3cm, font=\footnotesize\itshape, text=ethblue!70!black] at (5.5, 2*\layerSpacing) {Multiplexing};

    % --- LAYER 2: SECURITY ---
    \node[layer_box=orange] (sec) at (0, 1*\layerSpacing) {};
    \node[layer_label] at (-6.3, 1*\layerSpacing) {\textbf{2}};

    % Security protocols
    \node[proto_box=orange, minimum width=4cm] at (-2, 1*\layerSpacing) {TLS 1.3};
    \node[font=\footnotesize, text=gray] at (1.2, 1*\layerSpacing) {\textit{or}};
    \node[proto_box=orange, minimum width=4cm] at (4, 1*\layerSpacing) {Noise Protocol};

    \node[right=0.3cm, font=\footnotesize\itshape, text=orange!70!black] at (5.5, 1*\layerSpacing) {Security};

    % --- LAYER 1: TRANSPORT (Bottom) ---
    \node[layer_box=gray] (trans) at (0, 0) {};
    \node[layer_label] at (-6.3, 0) {\textbf{1}};

    % Transport protocols
    \node[proto_box=gray, minimum width=4cm] at (-2, 0) {QUIC (UDP)};
    \node[font=\footnotesize, text=gray] at (1.2, 0) {\textit{or}};
    \node[proto_box=gray, minimum width=4cm] at (4, 0) {TCP};

    \node[right=0.3cm, font=\footnotesize\itshape, text=gray!70!black] at (5.5, 0) {Transport};

    % --- DATA FLOW ARROW (Right side) ---
    \draw[data_arrow] (6.8, -0.5) -- (6.8, 3*\layerSpacing + 0.5);
    \node[rotate=90, font=\footnotesize\bfseries, text=gray!60] at (7.3, 1.5*\layerSpacing) {Data Flow};

    % --- ANNOTATIONS ---

    % Brace for "Built into QUIC"
    \draw[decorate, decoration={brace, amplitude=6pt, mirror}, thick, gray]
        (-6, -0.7) -- (-6, 2*\layerSpacing + 0.7)
        node[midway, left=10pt, align=right, font=\scriptsize, text=gray] {Integrated\\in QUIC};

    \end{tikzpicture}
    \caption{The Lean Consensus protocol stack. Data flows upward: raw bytes enter at the transport layer and emerge as structured consensus messages at the application layer. Note that QUIC integrates layers 1--3 into a single protocol, while the TCP path requires separate protocols for each layer.}
    \label{fig:protocol_stack}
\end{figure}

The elegance of this design lies in its modularity. A developer working on Gossipsub need not understand the intricacies of TLS handshakes. A security auditor examining the encryption layer need not concern themselves with stream multiplexing semantics. Each layer presents a clean interface to the layer above, hiding its internal complexity.

There is one important subtlety visible in Figure~\ref{fig:protocol_stack}: the QUIC protocol collapses layers 1 through 3 into a single integrated design. This is not merely an implementation detail---it is a deliberate architectural choice that yields significant performance benefits, as we shall see in the following section.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUBSECTION: QUIC TRANSPORT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{QUIC Transport}

QUIC (Quick UDP Internet Connections) is the primary transport protocol for Lean Consensus. Originally developed by Google and later standardized as RFC~9000, QUIC represents a fundamental rethinking of how internet protocols should be designed. To understand why QUIC matters, we must first understand the limitations of its predecessor.

\subsubsection{The Problem with TCP}

For decades, the Transmission Control Protocol (TCP) has been the workhorse of reliable internet communication. TCP provides a simple abstraction: a bidirectional stream of bytes that arrive in order and without corruption. Under the hood, TCP handles packet loss, retransmission, congestion control, and flow control---all invisible to the application.

However, TCP was designed in the 1970s for a very different network environment. Several of its design decisions have become liabilities in modern networks:

\begin{itemize}
    \item \textbf{Head-of-Line Blocking.}
    TCP guarantees that bytes arrive in exactly the order they were sent. If packet 5 is lost while packets 6, 7, and 8 arrive successfully, TCP will hold packets 6--8 in a buffer until packet 5 is retransmitted and received. The application sees nothing until the gap is filled.

    This behavior is catastrophic for multiplexed connections. Imagine a single TCP connection carrying ten independent streams. If one stream loses a packet, \emph{all ten streams} are blocked waiting for that single retransmission. The streams are logically independent, but TCP's ordering guarantee couples their fates.

    \item \textbf{Connection Establishment Latency.}
    Establishing a TCP connection requires a three-way handshake: SYN, SYN-ACK, ACK. If the connection also requires TLS encryption (and it always should), an additional handshake follows. This means a minimum of two round trips before any application data can flow---potentially hundreds of milliseconds on intercontinental links.

    \item \textbf{Ossified Middleboxes.}
    The internet is populated with middleboxes: firewalls, NAT devices, load balancers, and deep packet inspection systems. Many of these devices make assumptions about TCP behavior. Attempts to extend or improve TCP often fail because middleboxes drop packets with unfamiliar options. The protocol is effectively frozen.
\end{itemize}

\subsubsection{QUIC's Design}

QUIC addresses each of these problems through a clean-slate design built on UDP. The key insight is that UDP provides minimal guarantees---essentially just ``best effort'' packet delivery---which gives QUIC complete freedom to implement its own semantics.

\begin{enumerate}
    \item \textbf{Native Stream Multiplexing.}
    QUIC treats streams as first-class citizens. A single QUIC connection can carry thousands of independent streams, each with its own flow control and ordering guarantees. Crucially, packet loss on one stream does not affect other streams. If stream A loses a packet, stream A blocks; streams B, C, and D continue unimpeded.

    Figure~\ref{fig:quic_vs_tcp_hol} illustrates this difference. In the TCP scenario, a single lost packet freezes all logical streams. In QUIC, only the affected stream experiences delay.

    \item \textbf{Integrated Encryption.}
    QUIC does not layer security on top of transport---it bakes encryption into the protocol from the ground up. The initial handshake simultaneously establishes the connection and negotiates cryptographic parameters. Most QUIC packets are fully encrypted, including metadata that TCP would expose in plaintext.

    This integration enables a critical optimization: the handshake can complete in a single round trip (1-RTT), or even zero round trips (0-RTT) for repeat connections. Compare this to TCP+TLS, which requires a minimum of two round trips.

    \item \textbf{UDP as an Escape Hatch.}
    By building on UDP, QUIC sidesteps the ossified middlebox problem. Middleboxes generally pass UDP traffic without inspection (since UDP has no state to track). QUIC can evolve freely, deploying new features without waiting for the entire internet infrastructure to upgrade.

    \item \textbf{Connection Migration.}
    TCP connections are identified by a four-tuple: source IP, source port, destination IP, destination port. If any of these change---for example, when a mobile device switches from WiFi to cellular---the connection breaks and must be re-established.

    QUIC connections are identified by a connection ID, a random token chosen during the handshake. The connection survives network changes; only the routing information updates. This property is particularly valuable for validators running on dynamic infrastructure.
\end{enumerate}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
        font=\sffamily\small,
        % Packet styles
        packet/.style={
            rectangle,
            draw=#1,
            thick,
            fill=#1!15,
            minimum width=0.8cm,
            minimum height=0.6cm,
            font=\scriptsize\bfseries
        },
        lost_packet/.style={
            packet=red,
            fill=red!20,
            pattern=north east lines,
            pattern color=red!50
        },
        blocked_packet/.style={
            packet=gray,
            fill=gray!10,
            opacity=0.5
        },
        % Stream label
        stream_label/.style={
            font=\footnotesize\bfseries,
            anchor=east
        },
        % Section headers
        section_header/.style={
            font=\bfseries\normalsize,
            anchor=south
        }
    ]

    % --- TCP SCENARIO (Left) ---
    \node[section_header] at (2.5, 4.2) {TCP + Multiplexing};

    % Single TCP pipe
    \draw[ultra thick, gray!50, rounded corners=3pt] (-0.3, 0.3) rectangle (5.3, 3.5);
    \node[font=\tiny, text=gray, anchor=north west] at (-0.2, 3.4) {Single TCP Connection};

    % Stream A
    \node[stream_label] at (-0.5, 3) {Stream A};
    \node[packet=ethblue] at (0.5, 3) {1};
    \node[packet=ethblue] at (1.5, 3) {2};
    \node[lost_packet] at (2.5, 3) {3};
    \node[blocked_packet] at (3.5, 3) {4};
    \node[blocked_packet] at (4.5, 3) {5};

    % Stream B
    \node[stream_label] at (-0.5, 2) {Stream B};
    \node[packet=leanpurple] at (0.5, 2) {1};
    \node[packet=leanpurple] at (1.5, 2) {2};
    \node[blocked_packet] at (2.5, 2) {3};
    \node[blocked_packet] at (3.5, 2) {4};
    \node[blocked_packet] at (4.5, 2) {5};

    % Stream C
    \node[stream_label] at (-0.5, 1) {Stream C};
    \node[packet=orange] at (0.5, 1) {1};
    \node[packet=orange] at (1.5, 1) {2};
    \node[blocked_packet] at (2.5, 1) {3};
    \node[blocked_packet] at (3.5, 1) {4};
    \node[blocked_packet] at (4.5, 1) {5};

    % Blocking annotation
    \draw[<-, thick, red] (2.5, 3.7) -- (2.5, 4.0) node[above, font=\scriptsize, text=red] {Packet Lost};
    \draw[decorate, decoration={brace, amplitude=5pt, raise=2pt}, thick, red]
        (2.3, 0.6) -- (4.7, 0.6)
        node[midway, below=8pt, font=\scriptsize, text=red, align=center] {ALL streams\\blocked};


    % --- QUIC SCENARIO (Right) ---
    \node[section_header] at (10.5, 4.2) {QUIC};

    % QUIC connection (more open representation)
    \draw[ultra thick, gray!50, rounded corners=3pt, dashed] (7.7, 0.3) rectangle (13.3, 3.5);
    \node[font=\tiny, text=gray, anchor=north west] at (7.8, 3.4) {Single QUIC Connection};

    % Stream A (affected)
    \node[stream_label] at (7.5, 3) {Stream A};
    \node[packet=ethblue] at (8.5, 3) {1};
    \node[packet=ethblue] at (9.5, 3) {2};
    \node[lost_packet] at (10.5, 3) {3};
    \node[blocked_packet] at (11.5, 3) {4};
    \node[blocked_packet] at (12.5, 3) {5};

    % Stream B (unaffected - continues normally)
    \node[stream_label] at (7.5, 2) {Stream B};
    \node[packet=leanpurple] at (8.5, 2) {1};
    \node[packet=leanpurple] at (9.5, 2) {2};
    \node[packet=leanpurple] at (10.5, 2) {3};
    \node[packet=leanpurple] at (11.5, 2) {4};
    \node[packet=leanpurple] at (12.5, 2) {5};

    % Stream C (unaffected - continues normally)
    \node[stream_label] at (7.5, 1) {Stream C};
    \node[packet=orange] at (8.5, 1) {1};
    \node[packet=orange] at (9.5, 1) {2};
    \node[packet=orange] at (10.5, 1) {3};
    \node[packet=orange] at (11.5, 1) {4};
    \node[packet=orange] at (12.5, 1) {5};

    % Annotation for QUIC
    \draw[<-, thick, red] (10.5, 3.7) -- (10.5, 4.0) node[above, font=\scriptsize, text=red] {Packet Lost};
    \draw[decorate, decoration={brace, amplitude=5pt}, thick, green!60!black]
        (11.3, 0.6) -- (12.7, 0.6)
        node[midway, below=8pt, font=\scriptsize, text=green!60!black, align=center] {Other streams\\continue};

    % Checkmarks for unblocked streams
    \node[text=green!60!black, font=\bfseries] at (13.0, 2) {\checkmark};
    \node[text=green!60!black, font=\bfseries] at (13.0, 1) {\checkmark};

    \end{tikzpicture}
    \caption{Head-of-line blocking comparison. \textbf{Left:} In TCP with application-layer multiplexing, a single lost packet (Stream A, packet 3) blocks all streams until retransmission completes. \textbf{Right:} In QUIC, streams are independent---only Stream A is affected; Streams B and C continue to make progress.}
    \label{fig:quic_vs_tcp_hol}
\end{figure}

\subsubsection{QUIC in Lean Consensus}

For Ethereum's consensus layer, QUIC's properties align well with operational requirements:

\begin{itemize}
    \item \textbf{Multiple Concurrent Protocols.}
    A validator simultaneously participates in block gossip, attestation gossip, sync protocols, and status exchanges. Each of these can run on its own QUIC stream, isolated from the others. A slow sync operation does not delay time-critical attestation propagation.

    \item \textbf{Fast Connection Establishment.}
    Validators frequently establish new connections as peers join and leave the network. QUIC's 1-RTT (or 0-RTT) handshake minimizes the latency penalty for new connections.

    \item \textbf{Resilience to Network Instability.}
    Validators may run on cloud infrastructure with dynamic IP addresses, or on home connections with occasional interruptions. QUIC's connection migration and robust loss recovery help maintain connectivity.
\end{itemize}

The integration of TLS~1.3 into QUIC means that security is not an afterthought. Every QUIC connection is encrypted by default, with no option to disable encryption. This eliminates an entire class of configuration errors that have plagued TCP deployments.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUBSECTION: ALTERNATIVE TRANSPORTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Alternative Transports}

While QUIC is the preferred transport, it is not universally available. Some network environments block UDP traffic entirely, or apply aggressive rate limiting that renders QUIC unusable. Corporate firewalls, certain ISPs, and some cloud providers fall into this category.

To ensure that validators can participate regardless of their network environment, Lean Consensus supports an alternative transport stack built on TCP. This fallback path replicates QUIC's functionality using separate protocols for each layer.

\subsubsection{TCP as the Foundation}

TCP provides reliable, ordered byte stream delivery---the same abstraction that QUIC builds internally. The difference is that TCP exposes only a single stream per connection, and its security and multiplexing must be added externally.

Using TCP as a fallback is straightforward because it is universally supported. Every operating system, every network, and every middlebox understands TCP. This ubiquity comes at the cost of the performance limitations discussed earlier.

\subsubsection{The Noise Protocol Framework}

When TCP is the transport, encryption is provided by the Noise Protocol Framework rather than TLS. Noise is a family of cryptographic protocols designed for simplicity and flexibility. Unlike TLS, which has accumulated decades of extensions and negotiation options, Noise protocols are specified by a compact pattern string that fully determines the handshake behavior.

For Lean Consensus, the relevant Noise pattern is \texttt{XX}:

\begin{enumerate}
    \item The initiator sends an ephemeral public key.
    \item The responder sends an ephemeral public key and their static public key (encrypted).
    \item The initiator sends their static public key (encrypted) and begins sending application data.
\end{enumerate}

The \texttt{XX} pattern provides mutual authentication: both parties learn each other's long-term identity. It also provides forward secrecy: compromise of long-term keys does not reveal past session traffic.

\begin{infobox}{Why Noise Instead of TLS?}
TLS and Noise solve the same fundamental problem---authenticated key exchange---but they make different trade-offs.

TLS is designed for the web, where servers have certificates signed by trusted authorities and clients are often anonymous. The protocol includes extensive negotiation for cipher suites, extensions, and certificate chains.

Noise is designed for peer-to-peer systems where both parties have known public keys and no certificate authority exists. The protocol is minimal: a Noise implementation can be written in a few hundred lines of code, compared to tens of thousands for TLS.

For Ethereum's P2P network, Noise's simplicity is an advantage. Node identities are self-certified (derived from cryptographic keys), and there is no need for the PKI infrastructure that TLS assumes.
\end{infobox}

\subsubsection{Yamux Multiplexing}

With TCP providing transport and Noise providing security, the remaining gap is multiplexing. This is filled by Yamux (Yet Another Multiplexer), a lightweight protocol that creates multiple logical streams over a single TCP connection.

Yamux operates by framing: each chunk of data is wrapped in a header that identifies which stream it belongs to. Streams can be opened and closed independently, and each stream has its own flow control window to prevent a fast sender from overwhelming a slow receiver.

The Yamux design is deliberately simple:

\begin{itemize}
    \item \textbf{Stream IDs.} Each stream is identified by a 32-bit integer. The initiator uses odd IDs; the responder uses even IDs. This prevents collisions without coordination.

    \item \textbf{Frame Types.} Four frame types exist: data (carrying payload), window update (adjusting flow control), ping (keepalive), and go-away (connection shutdown).

    \item \textbf{Flow Control.} Each stream maintains a receive window. The sender may not transmit more data than the receiver has advertised space for. Window updates are sent as the receiver processes data.
\end{itemize}

Unlike QUIC's native streams, Yamux streams share the underlying TCP connection's fate. If TCP experiences packet loss, all Yamux streams block together. This is the fundamental limitation that makes TCP+Yamux inferior to QUIC.

\subsubsection{Choosing a Transport}

The selection between QUIC and TCP is typically automatic. A Lean Consensus node first attempts to connect via QUIC. If the connection fails or times out (indicating that UDP may be blocked), the node falls back to TCP with Noise and Yamux.

Figure~\ref{fig:transport_selection} illustrates this decision process. In practice, the vast majority of connections use QUIC. The TCP fallback exists as a safety net, ensuring that no validator is excluded from the network due to restrictive network policies.

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
        font=\sffamily\small,
        % Node styles
        decision/.style={
            diamond,
            draw=ethblue,
            thick,
            fill=ethblue!10,
            text width=2.2cm,
            align=center,
            inner sep=2pt,
            aspect=1.5
        },
        process/.style={
            rectangle,
            draw=gray,
            thick,
            fill=softgray,
            minimum width=3cm,
            minimum height=0.8cm,
            align=center,
            rounded corners=2pt
        },
        result/.style={
            rectangle,
            draw=#1,
            thick,
            fill=#1!15,
            minimum width=3.5cm,
            minimum height=1.2cm,
            align=center,
            rounded corners=3pt
        },
        arrow/.style={->, >=Latex, thick, ethblue}
    ]

    % Start
    \node[process] (start) at (0, 0) {Initiate Connection};

    % Try QUIC
    \node[process, below=1cm of start] (try_quic) {Attempt QUIC\\(UDP)};

    % Decision: QUIC works?
    \node[decision, below=1.2cm of try_quic] (quic_ok) {Success?};

    % QUIC result (left)
    \node[result=green!60!black, left=2cm of quic_ok] (use_quic) {
        \textbf{Use QUIC}\\
        \scriptsize Integrated TLS 1.3\\
        \scriptsize Native multiplexing
    };

    % Try TCP (right path)
    \node[process, right=2cm of quic_ok] (try_tcp) {Fallback to TCP};

    % TCP stack
    \node[result=orange, below=1cm of try_tcp] (use_tcp) {
        \textbf{Use TCP Stack}\\
        \scriptsize Noise Protocol\\
        \scriptsize Yamux multiplexing
    };

    % Arrows
    \draw[arrow] (start) -- (try_quic);
    \draw[arrow] (try_quic) -- (quic_ok);
    \draw[arrow] (quic_ok) -- node[above, font=\scriptsize] {Yes} (use_quic);
    \draw[arrow] (quic_ok) -- node[above, font=\scriptsize] {No / Timeout} (try_tcp);
    \draw[arrow] (try_tcp) -- (use_tcp);

    % Performance annotations
    \node[below=0.3cm of use_quic, font=\scriptsize\itshape, text=green!60!black] {Preferred (faster)};
    \node[below=0.3cm of use_tcp, font=\scriptsize\itshape, text=orange] {Fallback (compatible)};

    \end{tikzpicture}
    \caption{Transport selection logic. QUIC is attempted first due to its superior performance. If QUIC fails (typically due to UDP being blocked), the node falls back to the TCP-based stack.}
    \label{fig:transport_selection}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SUBSECTION: CONNECTION SECURITY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Connection Security}

Every connection in the Lean Consensus network is encrypted and authenticated. There are no exceptions, no optional modes, and no way to disable security. This design principle---encryption by default---eliminates configuration errors and ensures that even misconfigured nodes cannot accidentally expose sensitive data.

This section examines the cryptographic mechanisms that secure connections, focusing on TLS~1.3 (used with QUIC) while noting the parallels with Noise (used with TCP).

\subsubsection{Goals of Connection Security}

Before diving into protocols, it is worth stating explicitly what we are trying to achieve:

\begin{enumerate}
    \item \textbf{Confidentiality.}
    An eavesdropper observing network traffic should learn nothing about the content of messages. Even if an attacker can see every packet, they should not be able to determine whether a node is gossiping blocks, requesting sync data, or exchanging status information.

    \item \textbf{Integrity.}
    A man-in-the-middle should not be able to modify messages in transit. If an attacker intercepts a packet and alters it, the recipient must detect the tampering and reject the message.

    \item \textbf{Authentication.}
    Each party must be certain of the other's identity. When node A connects to node B, node A must be confident that it is actually communicating with B and not an imposter. This is particularly important in a system where node identity determines consensus weight.

    \item \textbf{Forward Secrecy.}
    Compromise of long-term keys should not compromise past communications. If an attacker later obtains a node's private key, they should not be able to decrypt traffic they previously recorded.
\end{enumerate}

\subsubsection{TLS 1.3 Overview}

TLS (Transport Layer Security) is the most widely deployed security protocol on the internet. Version 1.3, published in 2018, represents a significant simplification over previous versions, removing obsolete cryptographic options and streamlining the handshake.

The TLS~1.3 handshake, illustrated in Figure~\ref{fig:tls_handshake}, proceeds as follows:

\begin{enumerate}
    \item \textbf{ClientHello.}
    The initiator (client) sends a message containing:
    \begin{itemize}
        \item Supported cipher suites (encryption algorithms)
        \item Supported key exchange groups
        \item A random nonce
        \item Key shares for anticipated key exchange groups
    \end{itemize}

    The inclusion of key shares in the first message is a TLS~1.3 innovation. In previous versions, the client had to wait for the server's response before sending key material, adding a round trip.

    \item \textbf{ServerHello.}
    The responder (server) selects a cipher suite and key exchange group from the client's offerings, and sends:
    \begin{itemize}
        \item The selected parameters
        \item Its own random nonce
        \item Its key share
    \end{itemize}

    At this point, both parties can compute a shared secret using Diffie-Hellman key exchange. All subsequent messages are encrypted.

    \item \textbf{Encrypted Extensions and Certificate.}
    The server sends additional configuration parameters (encrypted) and its certificate. In Lean Consensus, the certificate contains the node's public key, allowing the client to verify the server's identity.

    \item \textbf{Certificate Verify.}
    The server proves possession of the private key corresponding to its certificate by signing the handshake transcript. This prevents an attacker from replaying a stolen certificate.

    \item \textbf{Finished.}
    Both parties send a \texttt{Finished} message containing a MAC (Message Authentication Code) over the entire handshake. This confirms that neither party's messages were tampered with.
\end{enumerate}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
        font=\sffamily\small,
        % Node styles
        party/.style={
            rectangle,
            draw=ethblue,
            thick,
            fill=ethblue!10,
            minimum width=2.8cm,
            minimum height=1cm,
            align=center,
            rounded corners=3pt
        },
        % Message arrow styles
        msg_arrow/.style={
            ->,
            >=Latex,
            thick,
            #1
        },
        % Message label styles
        msg_label/.style={
            fill=white,
            inner sep=2pt,
            font=\footnotesize
        },
        % Phase annotation
        phase/.style={
            font=\scriptsize\itshape,
            text=gray
        }
    ]

    % Define horizontal positions
    \def\clientX{0}
    \def\serverX{8}
    \def\msgStart{0.4}

    % Parties
    \node[party] (client) at (\clientX, 0) {\textbf{Client}\\(Initiator)};
    \node[party] (server) at (\serverX, 0) {\textbf{Server}\\(Responder)};

    % Vertical lines (timeline)
    \draw[thick, gray!50] (\clientX, -0.7) -- (\clientX, -9.5);
    \draw[thick, gray!50] (\serverX, -0.7) -- (\serverX, -9.5);

    % --- PHASE 1: Key Exchange ---
    \node[phase, anchor=east] at (-0.5, -1.3) {Key Exchange};

    % ClientHello
    \draw[msg_arrow=ethblue] (\clientX + \msgStart, -1.5) -- (\serverX - \msgStart, -1.5)
        node[msg_label, midway, above] {\texttt{ClientHello}};
    \node[font=\tiny, text=gray, anchor=west] at (\serverX + 0.3, -1.5) {+ key\_share};

    % ServerHello
    \draw[msg_arrow=leanpurple] (\serverX - \msgStart, -2.3) -- (\clientX + \msgStart, -2.3)
        node[msg_label, midway, above] {\texttt{ServerHello}};
    \node[font=\tiny, text=gray, anchor=east] at (\clientX - 0.3, -2.3) {+ key\_share};

    % Shared secret computed
    \draw[dashed, gray] (-1, -3.0) -- (9, -3.0);
    \node[font=\scriptsize\bfseries, text=green!60!black, fill=white, inner sep=3pt] at (4, -3.0) {Shared Secret Established};

    % --- PHASE 2: Server Authentication (Encrypted) ---
    \node[phase, anchor=east] at (-0.5, -3.8) {Authentication};

    % Encrypted indicator
    \draw[thick, orange!70, decorate, decoration={snake, amplitude=1pt, segment length=8pt}]
        (-0.8, -3.5) -- (-0.8, -6.5);
    \node[font=\tiny, text=orange, rotate=90] at (-1.1, -5) {ENCRYPTED};

    % EncryptedExtensions
    \draw[msg_arrow=leanpurple] (\serverX - \msgStart, -4.0) -- (\clientX + \msgStart, -4.0)
        node[msg_label, midway, above] {\texttt{EncryptedExtensions}};

    % Certificate
    \draw[msg_arrow=leanpurple] (\serverX - \msgStart, -4.8) -- (\clientX + \msgStart, -4.8)
        node[msg_label, midway, above] {\texttt{Certificate}};
    \node[font=\tiny, text=gray, anchor=east] at (\clientX - 0.3, -4.8) {Node public key};

    % CertificateVerify
    \draw[msg_arrow=leanpurple] (\serverX - \msgStart, -5.6) -- (\clientX + \msgStart, -5.6)
        node[msg_label, midway, above] {\texttt{CertificateVerify}};
    \node[font=\tiny, text=gray, anchor=east] at (\clientX - 0.3, -5.6) {Signature proof};

    % Server Finished
    \draw[msg_arrow=leanpurple] (\serverX - \msgStart, -6.4) -- (\clientX + \msgStart, -6.4)
        node[msg_label, midway, above] {\texttt{Finished}};

    % --- PHASE 3: Client Authentication & Data ---
    \node[phase, anchor=east] at (-0.5, -7.2) {Confirmation};

    % Client Finished
    \draw[msg_arrow=ethblue] (\clientX + \msgStart, -7.5) -- (\serverX - \msgStart, -7.5)
        node[msg_label, midway, above] {\texttt{Finished}};

    % Application data
    \draw[dashed, gray] (-1, -8.2) -- (9, -8.2);
    \node[font=\scriptsize\bfseries, text=green!60!black, fill=white, inner sep=3pt] at (4, -8.2) {Handshake Complete};

    % Bidirectional data
    \draw[msg_arrow=green!60!black, <->] (\clientX + \msgStart, -9.0) -- (\serverX - \msgStart, -9.0)
        node[msg_label, midway, above] {\texttt{Application Data}};

    % RTT annotation
    \draw[<->, thick, gray] (9.5, -1.5) -- (9.5, -7.5);
    \node[font=\scriptsize, text=gray, rotate=90] at (9.9, -4.5) {1 Round Trip};

    \end{tikzpicture}
    \caption{The TLS 1.3 handshake. The client sends key material in the first message, enabling the handshake to complete in a single round trip. All messages after \texttt{ServerHello} are encrypted. Note that the server authenticates first; client authentication (mutual TLS) can be added if required.}
    \label{fig:tls_handshake}
\end{figure}

\subsubsection{Node Identity and Certificates}

In traditional TLS deployments (such as HTTPS), servers present certificates signed by trusted Certificate Authorities (CAs). Clients maintain a list of trusted CA public keys and verify the chain of signatures.

Ethereum's P2P network has no certificate authorities. Instead, node identity is self-certifying: a node's identity \emph{is} its public key. The certificate presented during TLS contains this public key directly, without any CA signature.

This approach works because Ethereum nodes discover each other through ENRs, which contain the expected public key. When node A connects to node B, node A already knows B's public key from B's ENR. The TLS handshake simply confirms that the remote party possesses the corresponding private key.

The verification process is:

\begin{enumerate}
    \item Node A looks up node B's ENR, which contains B's public key $pk_B$.
    \item Node A initiates a TLS connection to B's advertised address.
    \item Node B presents a certificate containing public key $pk'_B$.
    \item Node A verifies that $pk'_B = pk_B$. If not, the connection is rejected.
    \item Node B proves possession of the private key by signing the handshake (CertificateVerify).
\end{enumerate}

This model inverts the trust relationship of traditional PKI. Rather than trusting a third party to vouch for identity, we trust cryptographic binding: if you can sign with key $k$, you \emph{are} the entity identified by $k$.

\subsubsection{Perfect Forward Secrecy}

Both TLS~1.3 and Noise provide \emph{perfect forward secrecy} (PFS), a property that protects past communications even if long-term keys are later compromised.

The mechanism is ephemeral key exchange. During the handshake, both parties generate fresh, temporary key pairs. The shared secret is derived from these ephemeral keys, not from the long-term identity keys. After the handshake, the ephemeral private keys are discarded.

Consider an attacker who records all encrypted traffic between two nodes. Later, the attacker compromises one node and obtains its long-term private key. Without PFS, the attacker could use this key to decrypt all recorded traffic. With PFS, the attacker learns nothing: the ephemeral keys that protected each session are gone, destroyed after use.

Figure~\ref{fig:forward_secrecy} illustrates this protection. The long-term key is used only for authentication (proving identity), not for encryption. Session keys are derived from ephemeral material that exists only for the duration of the handshake.

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
        font=\sffamily\small,
        % Key styles
        key_box/.style={
            rectangle,
            draw=#1,
            thick,
            fill=#1!15,
            minimum width=2.8cm,
            minimum height=0.9cm,
            align=center,
            rounded corners=3pt
        },
        % Session styles
        session_box/.style={
            rectangle,
            draw=gray,
            dashed,
            fill=softgray,
            minimum width=9cm,
            minimum height=1.6cm,
            rounded corners=3pt
        },
        % Arrow styles
        derive_arrow/.style={->, >=Latex, thick, ethblue},
        auth_arrow/.style={->, >=Latex, thick, dashed, gray}
    ]

    % Long-term identity key (top)
    \node[key_box=leanpurple] (ltk) at (0, 3) {
        \textbf{Long-Term Key}\\
        \scriptsize (Identity)
    };

    % Session 1
    \node[session_box] (s1) at (0, 0.8) {};
    \node[font=\scriptsize\bfseries, anchor=north west, text=gray] at (-4.3, 1.5) {Session 1};

    \node[key_box=ethblue] (eph1) at (-2, 0.8) {
        \textbf{Ephemeral Key}\\
        \scriptsize (Generated fresh)
    };

    \node[key_box=green!60!black] (sess1) at (2, 0.8) {
        \textbf{Session Key}\\
        \scriptsize (Encrypts data)
    };

    \draw[derive_arrow] (eph1) -- (sess1);
    \draw[auth_arrow] (ltk) -- node[right, font=\tiny, text=gray] {Auth only} (eph1);

    % Destruction annotation
    \node[text=red, font=\scriptsize\bfseries] at (4, 0.8) {$\times$ Destroyed};

    % Session 2
    \node[session_box] (s2) at (0, -1.4) {};
    \node[font=\scriptsize\bfseries, anchor=north west, text=gray] at (-4.3, -0.7) {Session 2};

    \node[key_box=ethblue] (eph2) at (-2, -1.4) {
        \textbf{Ephemeral Key}\\
        \scriptsize (New, independent)
    };

    \node[key_box=green!60!black] (sess2) at (2, -1.4) {
        \textbf{Session Key}\\
        \scriptsize (Different key)
    };

    \draw[derive_arrow] (eph2) -- (sess2);
    \draw[auth_arrow] (ltk) -- (eph2);

    \node[text=red, font=\scriptsize\bfseries] at (4, -1.4) {$\times$ Destroyed};

    % Attack scenario annotation
    \node[
        rectangle,
        draw=red,
        thick,
        fill=red!5,
        text width=8cm,
        align=left,
        rounded corners=3pt,
        font=\footnotesize
    ] at (0, -3.5) {
        \textbf{If long-term key is compromised:}\\
        \textcolor{green!60!black}{\checkmark} Past sessions remain protected (ephemeral keys are gone)\\
        \textcolor{red}{$\times$} Future sessions can be impersonated (but not decrypted retroactively)
    };

    \end{tikzpicture}
    \caption{Perfect forward secrecy. Each session uses a fresh ephemeral key to derive the session encryption key. The long-term key only authenticates the ephemeral key exchange. After the session ends, ephemeral keys are destroyed, making past traffic undecryptable even if the long-term key is later compromised.}
    \label{fig:forward_secrecy}
\end{figure}

\subsubsection{Cipher Suites}

A cipher suite is a specific combination of cryptographic algorithms used together. TLS~1.3 dramatically reduced the number of supported cipher suites compared to earlier versions, eliminating weak and obsolete options.

The cipher suites relevant to Lean Consensus are:

\begin{itemize}
    \item \textbf{TLS\_AES\_128\_GCM\_SHA256}: AES-128 encryption in Galois/Counter Mode, with SHA-256 for the handshake hash.
    \item \textbf{TLS\_AES\_256\_GCM\_SHA384}: AES-256 encryption with SHA-384.
    \item \textbf{TLS\_CHACHA20\_POLY1305\_SHA256}: ChaCha20 stream cipher with Poly1305 authenticator.
\end{itemize}

All of these provide authenticated encryption---they protect both confidentiality (content is secret) and integrity (tampering is detected). The choice between them is largely a matter of hardware support: AES-GCM is faster on processors with AES hardware acceleration, while ChaCha20 is faster in software on processors without such acceleration.

For key exchange, TLS~1.3 uses elliptic curve Diffie-Hellman. The supported curves include X25519 (Curve25519) and P-256. X25519 is preferred for its simplicity and resistance to implementation errors.

\begin{infobox}{Security in Depth}
The Lean Consensus network implements security at multiple layers:

\begin{enumerate}
    \item \textbf{Transport Layer:} TLS/Noise encrypts all data in transit. Eavesdroppers see only ciphertext.

    \item \textbf{Application Layer:} Consensus messages (blocks, attestations) are signed by validators. Even if transport encryption were somehow bypassed, forged messages would fail signature verification.

    \item \textbf{Protocol Layer:} Consensus rules reject invalid state transitions. Even authenticated messages that violate protocol semantics are discarded.
\end{enumerate}

This defense-in-depth approach means that compromising any single layer is insufficient to attack the system. An adversary would need to break multiple independent security mechanisms simultaneously.
\end{infobox}
